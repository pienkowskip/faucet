#!/usr/bin/env ruby

require 'plunder'
require 'plunder/moon_faucet'
require 'plunder/utility/downtime'

['INT', 'TERM'].each do |signal|
  Signal.trap(signal) { exit 0 }
end

require_relative 'setups/ovh'

begin
  $app.setup_browser

  downtime = Plunder::Utility::Downtime.new($app.dm.random, *$breaks)

  $faucets.map! do |url, address|
    faucet = Plunder::MoonFaucet.new($app.dm, url, address)
    task = -> do
      delay = nil
      begin
        faucet.claim
        $app.browser.visit('about:blank')
      rescue Plunder::Error => exc
        $app.logger.error { 'Faucet claiming error: %s (%s).' % [exc.message, exc.class] }
        $app.restart_browser if exc.is_a?(Plunder::FatalBrowserError) # not sure if necessary?
        $app.diagnostic_dump(exc)
        delay = faucet.next_claim_delay(exc)
      end
      delay = faucet.next_claim_delay unless delay
      $app.dm.scheduler.add_task(task, downtime.shift(Time.new + delay))
    end
    $app.dm.scheduler.add_task(task, downtime.shift(Time.new))
  end

  loop do
    $app.dm.scheduler.execute_next_task
  end
rescue SystemExit => exc
  $app.logger.info { 'Exit signal received. Quitting application.' }
  raise exc
rescue => exc
  begin
    $app.logger.fatal { "Uncaught exception: #{exc.message} (#{exc.class})." }
    $app.diagnostic_dump(exc)
  rescue => nested_exc
    $app.logger.error { 'Error: %s (%s).' % [nested_exc.message, nested_exc.class] }
  ensure
    raise exc
  end
ensure
  begin
    $app.quit_browser
  rescue => ensure_exc
    $app.logger.error { 'Error: %s (%s).' % [ensure_exc.message, ensure_exc.class] }
  end
end